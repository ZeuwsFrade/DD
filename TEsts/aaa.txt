extends CharacterBody2D

@export var tile_map: TileMapLayer
@export var SPEED = 200
const tile_width = 16
var current_path: Array[Vector2i]

var acces = {}
@onready var enemy = get_tree().get_nodes_in_group("enemy")

func _moving():
	if current_path.is_empty():
		return
	var target_position = tile_map.map_to_local(current_path.front())
	global_position = global_position.move_toward(target_position, SPEED)
	if global_position == target_position:
		current_path.pop_front()
	_moving()

func _unhandled_input(event):
	if !current_path.is_empty(): return
	for i in acces:
		if !acces.is_empty() and acces[i] != true:
			return
	var input_dir := Input.get_vector("move_left", "move_right", "move_up", "move_down")
	var direction := Vector2(floor(input_dir.x), floor(input_dir.y)).normalized()
	if direction:
		if tile_map.is_point_available(global_position+direction*tile_width):
			current_path = tile_map.astar.get_id_path(
				tile_map.local_to_map(global_position),
				tile_map.local_to_map(global_position+direction*tile_width)
				).slice(1)
		acces.clear()
		_moving()
		get_tree().call_group("enemy", "_move")
		
		
		
		
		
		
		
		
		
		
	extends CharacterBody2D

@export var tile_map: TileMapLayer
@export var SPEED = 200
const tile_width = 16
var current_path: Array[Vector2i]
var beta_current_path: Array[Vector2i]
var next_pos = Vector2i()

var range = 1 # можно цикл е
var is_turn = false

@onready var player = get_tree().get_nodes_in_group("player")[0]

func  _moving():
	if current_path.is_empty():
		return
	var target_position = tile_map.map_to_local(current_path.front())
	global_position = global_position.move_toward(target_position, SPEED)
	if global_position == target_position:
		current_path.pop_front()
	_moving()

func _move():
	beta_current_path = tile_map.astar.get_id_path(
		tile_map.local_to_map(global_position),
		tile_map.local_to_map(player.global_position)
		).slice(1)
	if beta_current_path.size() > range:
		beta_current_path.resize(range)
		next_pos = beta_current_path.back()
	if tile_map.is_point_available(tile_map.map_to_local(beta_current_path.back())):
		current_path = beta_current_path
		_moving()









extends TileMapLayer

var astar = AStarGrid2D.new()
var tilemap_size = get_used_rect().end - get_used_rect().position
var map_rect = Rect2i(Vector2i.ZERO, tilemap_size)
# Called when the node enters the scene tree for the first time.
func _ready() -> void:
	astar.region = map_rect
	astar.cell_size = tile_set.tile_size
	astar.default_compute_heuristic = AStarGrid2D.HEURISTIC_MANHATTAN
	astar.default_estimate_heuristic = AStarGrid2D.HEURISTIC_MANHATTAN
	astar.diagonal_mode = AStarGrid2D.DIAGONAL_MODE_NEVER
	astar.update()
	
	for i in tilemap_size.x:
		for j in tilemap_size.y:
			var coords = Vector2(i, j)
			var tile_data = get_cell_tile_data(coords)
			if tile_data and tile_data.get_custom_data('Type') == 'Wall':
				astar.set_point_solid(coords)
	pass # Replace with function body.


@onready var player = get_tree().get_nodes_in_group("player")[0]
@onready var enemy = get_tree().get_nodes_in_group("enemy")

func is_point_available(position):
	var map_position = local_to_map(position)
	
	var _pos = Vector2(position.x, position.y)
	
	for i in enemy:
		if i.global_position == _pos:
			return false
	
	if player.global_position == _pos:
		return false
	
	if map_rect.has_point(map_position) and not astar.is_point_solid(map_position):
		return true
	else:
		return false
	
	
	
	
	

extends Node

var global_busy_point = []

# Called every frame. 'delta' is the elapsed time since the previous frame.
func _process(delta: float) -> void:
	pass
